<div className={styles.buttonGroup}>
        <Button onClick={applyChanges} variant="primary">
          Apply Changes
        </Button>
        <Button onClick={onClose} variant="secondary">
          Cancel
        </Button>
      </div>
    </div>
  );
};

// File: src/components/ServiceNodeDetails.tsx
import React from 'react';
import { ServiceNode } from '../types';
import { Modal, Button } from '@grafana/ui';
import { D3Utils } from '../utils/d3Utils';
import { css } from '@emotion/css';
import { GrafanaTheme2 } from '@grafana/data';
import { useStyles2 } from '@grafana/ui';

interface ServiceNodeDetailsProps {
  node?: ServiceNode;
  onClose: () => void;
}

const getDetailStyles = (theme: GrafanaTheme2) => ({
  container: css`
    padding: ${theme.spacing(2)};
  `,
  header: css`
    display: flex;
    align-items: center;
    margin-bottom: ${theme.spacing(3)};
  `,
  title: css`
    font-size: ${theme.typography.h4.fontSize};
    margin: 0;
    margin-left: ${theme.spacing(2)};
  `,
  status: css`
    display: inline-block;
    padding: ${theme.spacing(0.5, 1)};
    border-radius: ${theme.shape.borderRadius()};
    font-weight: ${theme.typography.fontWeightMedium};
    text-transform: uppercase;
    font-size: ${theme.typography.bodySmall.fontSize};
  `,
  metricsGrid: css`
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: ${theme.spacing(2)};
    margin-top: ${theme.spacing(2)};
  `,
  metric: css`
    padding: ${theme.spacing(2)};
    background: ${theme.colors.background.secondary};
    border-radius: ${theme.shape.borderRadius()};
    border: 1px solid ${theme.colors.border.medium};
  `,
  metricLabel: css`
    font-size: ${theme.typography.bodySmall.fontSize};
    color: ${theme.colors.text.secondary};
    margin-bottom: ${theme.spacing(0.5)};
  `,
  metricValue: css`
    font-size: ${theme.typography.h3.fontSize};
    font-weight: ${theme.typography.fontWeightMedium};
    color: ${theme.colors.text.primary};
  `,
  metricUnit: css`
    font-size: ${theme.typography.bodySmall.fontSize};
    color: ${theme.colors.text.secondary};
    margin-left: ${theme.spacing(0.5)};
  `,
});

export const ServiceNodeDetails: React.FC<ServiceNodeDetailsProps> = ({ node, onClose }) => {
  const styles = useStyles2(getDetailStyles);

  if (!node) return null;

  const statusColor = D3Utils.getStatusColor(node.status);

  return (
    <Modal title="" isOpen={true} onDismiss={onClose}>
      <div className={styles.container}>
        <div className={styles.header}>
          <div 
            style={{
              width: '40px',
              height: '40px',
              borderRadius: '50%',
              backgroundColor: node.color || D3Utils.getNodeColor(node.type),
              border: `3px solid ${statusColor}`,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              fontSize: '18px',
            }}
          >
            {node.icon || D3Utils.getNodeIcon(node.type)}
          </div>
          <h2 className={styles.title}>{node.name}</h2>
        </div>

        <div style={{ marginBottom: '16px' }}>
          <p><strong>Type:</strong> {node.type}</p>
          <p><strong>Status:</strong>{' '}
            <span 
              className={styles.status}
              style={{ 
                backgroundColor: statusColor + '20', 
                color: statusColor,
                border: `1px solid ${statusColor}`
              }}
            >
              {node.status}
            </span>
          </p>
          {node.group && <p><strong>Group:</strong> {node.group}</p>}
        </div>

        <div>
          <h4>Performance Metrics</h4>
          <div className={styles.metricsGrid}>
            <div className={styles.metric}>
              <div className={styles.metricLabel}>Request Rate</div>
              <div className={styles.metricValue}>
                {node.metrics.requestRate.toFixed(1)}
                <span className={styles.metricUnit}>req/s</span>
              </div>
            </div>
            
            <div className={styles.metric}>
              <div className={styles.metricLabel}>Error Rate</div>
              <div className={styles.metricValue}>
                {node.metrics.errorRate.toFixed(2)}
                <span className={styles.metricUnit}>%</span>
              </div>
            </div>
            
            <div className={styles.metric}>
              <div className={styles.metricLabel}>Latency</div>
              <div className={styles.metricValue}>
                {node.metrics.latency}
                <span className={styles.metricUnit}>ms</span>
              </div>
            </div>

            {node.metrics.cpu && (
              <div className={styles.metric}>
                <div className={styles.metricLabel}>CPU Usage</div>
                <div className={styles.metricValue}>
                  {node.metrics.cpu.toFixed(1)}
                  <span className={styles.metricUnit}>%</span>
                </div>
              </div>
            )}

            {node.metrics.memory && (
              <div className={styles.metric}>
                <div className={styles.metricLabel}>Memory Usage</div>
                <div className={styles.metricValue}>
                  {node.metrics.memory.toFixed(1)}
                  <span className={styles.metricUnit}>%</span>
                </div>
              </div>
            )}
          </div>
        </div>

        <Button onClick={onClose} style={{ marginTop: '16px' }}>
          Close
        </Button>
      </div>
    </Modal>
  );
};

// File: src/components/ServiceMapLegend.tsx
import React from 'react';
import { css } from '@emotion/css';
import { GrafanaTheme2 } from '@grafana/data';
import { useStyles2 } from '@grafana/ui';
import { D3Utils } from '../utils/d3Utils';

const getLegendStyles = (theme: GrafanaTheme2) => ({
  legend: css`
    position: absolute;
    bottom: ${theme.spacing(2)};
    left: ${theme.spacing(2)};
    background: ${theme.colors.background.secondary};
    border: 1px solid ${theme.colors.border.medium};
    border-radius: ${theme.shape.borderRadius()};
    padding: ${theme.spacing(2)};
    z-index: 1000;
    min-width: 200px;
    max-height: 400px;
    overflow-y: auto;
  `,
  section: css`
    margin-bottom: ${theme.spacing(2)};
    &:last-child { margin-bottom: 0; }
  `,
  title: css`
    font-weight: ${theme.typography.fontWeightMedium};
    margin-bottom: ${theme.spacing(1)};
    color: ${theme.colors.text.primary};
    font-size: ${theme.typography.body.fontSize};
  `,
  item: css`
    display: flex;
    align-items: center;
    margin-bottom: ${theme.spacing(0.5)};
    font-size: ${theme.typography.bodySmall.fontSize};
    color: ${theme.colors.text.secondary};
  `,
  indicator: css`
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: ${theme.spacing(1)};
    flex-shrink: 0;
  `,
  shapeIndicator: css`
    width: 16px;
    height: 16px;
    margin-right: ${theme.spacing(1)};
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  `,
});

export const ServiceMapLegend: React.FC = () => {
  const styles = useStyles2(getLegendStyles);

  const nodeTypes = [
    { type: 'service', label: 'Service', shape: '‚óè' },
    { type: 'database', label: 'Database', shape: '‚ñ†' },
    { type: 'external', label: 'External API', shape: '‚óÜ' },
    { type: 'frontend', label: 'Frontend', shape: '‚ñ≤' },
    { type: 'cache', label: 'Cache', shape: '‚óÜ' },
    { type: 'queue', label: 'Message Queue', shape: '‚¨°' },
  ];

  const statusTypes = [
    { status: 'healthy', label: 'Healthy' },
    { status: 'warning', label: 'Warning' },
    { status: 'critical', label: 'Critical' },
  ];

  return (
    <div className={styles.legend}>
      <div className={styles.section}>
        <div className={styles.title}>Node Types</div>
        {nodeTypes.map(({ type, label, shape }) => (
          <div key={type} className={styles.item}>
            <div 
              className={styles.shapeIndicator}
              style={{ color: D3Utils.getNodeColor(type) }}
            >
              {shape}
            </div>
            {label}
          </div>
        ))}
      </div>
      
      <div className={styles.section}>
        <div className={styles.title}>Health Status</div>
        {statusTypes.map(({ status, label }) => (
          <div key={status} className={styles.item}>
            <div 
              className={styles.indicator}
              style={{ backgroundColor: D3Utils.getStatusColor(status) }}
            />
            {label}
          </div>
        ))}
      </div>

      <div className={styles.section}>
        <div className={styles.title}>Interactions</div>
        <div style={{ fontSize: '11px', fontStyle: 'italic' }}>
          ‚Ä¢ Click: Select node<br/>
          ‚Ä¢ Drag: Move node<br/>
          ‚Ä¢ Double-click: Pin/unpin<br/>
          ‚Ä¢ Wheel: Zoom<br/>
          ‚Ä¢ Drag background: Pan
        </div>
      </div>
    </div>
  );
};

// File: src/data/ServiceMapDataProvider.ts
import { ServiceMapData, ServiceNode, ServiceEdge } from '../types';

export class ServiceMapDataProvider {
  async getData(): Promise<ServiceMapData> {
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 100));
    return this.getMockData();
  }

  private getMockData(): ServiceMapData {
    const nodes: ServiceNode[] = [
      {
        id: 'web-frontend',
        name: 'Web Frontend',
        type: 'frontend',
        status: 'healthy',
        size: 'large',
        shape: 'triangle',
        group: 'frontend',
        draggable: true,
        icon: 'üíª',
        metrics: {
          requestRate: 245.8,
          errorRate: 0.1,
          latency: 32,
          cpu: 45.2,
          memory: 62.8,
        },
      },
      {
        id: 'mobile-app',
        name: 'Mobile App',
        type: 'frontend',
        status: 'healthy',
        size: 'medium',
        shape: 'triangle',
        group: 'frontend',
        draggable: true,
        icon: 'üì±',
        metrics: {
          requestRate: 156.3,
          errorRate: 0.3,
          latency: 28,
          cpu: 38.7,
          memory: 54.1,
        },
      },
      {
        id: 'api-gateway',
        name: 'API Gateway',
        type: 'service',
        status: 'healthy',
        size: 'xlarge',
        shape: 'hexagon',
        group: 'backend',
        draggable: true,
        icon: 'üö™',
        metrics: {
          requestRate: 402.1,
          errorRate: 0.2,
          latency: 15,
          cpu: 52.3,
          memory: 71.4,
        },
      },
      {
        id: 'user-service',
        name: 'User Service',
        type: 'service',
        status: 'warning',
        size: 'large',
        shape: 'circle',
        group: 'backend',
        draggable: true,
        highlighted: true,
        icon: 'üë§',
        metrics: {
          requestRate: 67.2,
          errorRate: 2.8,
          latency: 156,
          cpu: 78.5,
          memory: 85.2,
        },
      },
      {
        id: 'order-service',
        name: 'Order Service',
        type: 'service',
        status: 'healthy',
        size: 'large',
        shape: 'circle',
        group: 'backend',
        draggable: true,
        icon: 'üì¶',
        metrics: {
          requestRate: 124.7,
          errorRate: 0.4,
          latency: 45,
          cpu: 42.8,
          memory: 59.3,
        },
      },
      {
        id: 'payment-service',
        name: 'Payment Service',
        type: 'service',
        status: 'critical',
        size: 'medium',
        shape: 'circle',
        group: 'backend',
        draggable: true,
        highlighted: true,
        icon: 'üí≥',
        metrics: {
          requestRate: 34.6,
          errorRate: 12.3,
          latency: 487,
          cpu: 89.2,
          memory: 94.7,
        },
      },
      {
        id: 'postgres-db',
        name: 'PostgreSQL',
        type: 'database',
        status: 'healthy',
        size: 'large',
        shape: 'square',
        group: 'data',
        draggable: false,
        pinned: true,
        icon: 'üóÑÔ∏è',
        metrics: {
          requestRate: 234.5,
          errorRate: 0.1,
          latency: 18,
          cpu: 65.4,
          memory: 72.1,
        },
      },
      {
        id: 'redis-cache',
        name: 'Redis Cache',
        type: 'cache',
        status: 'healthy',
        size: 'medium',
        shape: 'diamond',
        group: 'infrastructure',
        draggable: true,
        icon: '‚ö°',
        metrics: {
          requestRate: 567.8,
          errorRate: 0.0,
          latency: 3,
          cpu: 23.1,
          memory: 76.8,
        },
      },
      {
        id: 'external-payment-api',
        name: 'Payment Gateway',
        type: 'external',
        status: 'warning',
        size: 'small',
        shape: 'diamond',
        group: 'external',
        draggable: false,
        icon: 'üåê',
        metrics: {
          requestRate: 23.4,
          errorRate: 4.7,
          latency: 234,
        },
      },
    ];

    const edges: ServiceEdge[] = [
      {
        id: 'web-gateway',
        source: 'web-frontend',
        target: 'api-gateway',
        status: 'healthy',
        metrics: { requestRate: 245.8, errorRate: 0.1, latency: 8 },
      },
      {
        id: 'mobile-gateway',
        source: 'mobile-app',
        target: 'api-gateway',
        status: 'healthy',
        metrics: { requestRate: 156.3, errorRate: 0.3, latency: 12 },
      },
      {
        id: 'gateway-user',
        source: 'api-gateway',
        target: 'user-service',
        status: 'warning',
        metrics: { requestRate: 67.2, errorRate: 2.8, latency: 23 },
      },
      {
        id: 'gateway-order',
        source: 'api-gateway',
        target: 'order-service',
        status: 'healthy',
        metrics: { requestRate: 124.7, errorRate: 0.4, latency: 15 },
      },
      {
        id: 'order-payment',
        source: 'order-service',
        target: 'payment-service',
        status: 'critical',
        metrics: { requestRate: 34.6, errorRate: 12.3, latency: 35 },
      },
      {
        id: 'user-db',
        source: 'user-service',
        target: 'postgres-db',
        status: 'healthy',
        metrics: { requestRate: 45.8, errorRate: 0.1, latency: 12 },
      },
      {
        id: 'order-db',
        source: 'order-service',
        target: 'postgres-db',
        status: 'healthy',
        metrics: { requestRate: 89.2, errorRate: 0.1, latency: 15 },
      },
      {
        id: 'user-cache',
        source: 'user-service',
        target: 'redis-cache',
        status: 'healthy',
        metrics: { requestRate: 234.5, errorRate: 0.0, latency: 3 },
      },
      {
        id: 'payment-external',
        source: 'payment-service',
        target: 'external-payment-api',
        status: 'warning',
        metrics: { requestRate: 23.4, errorRate: 4.7, latency: 189 },
      },
    ];

    return {
      nodes,
      edges,
      timestamp: Date.now(),
    };
  }
}

// File: src/utils/d3Utils.ts
import * as d3 from 'd3';
import { D3Node, D3Link, ServiceNode } from '../types';
import { GrafanaTheme2 } from '@grafana/data';

export class D3Utils {
  static getStatusColor(status: string): string {
    switch (status) {
      case 'healthy': return '#52c41a';
      case 'warning': return '#faad14';
      case 'critical': return '#f5222d';
      default: return '#8c8c8c';
    }
  }

  static getNodeColor(type: string): string {
    switch (type) {
      case 'service': return '#1f77b4';
      case 'database': return '#ff7f0e';
      case 'external': return '#2ca02c';
      case 'frontend': return '#d62728';
      case 'cache': return '#9467bd';
      case 'queue': return '#8c564b';
      default: return '#7f7f7f';
    }
  }

  static getNodeRadius(node: ServiceNode | D3Node): number {
    const baseRadius = 20;
    let sizeMultiplier = 1;

    switch (node.size) {
      case 'small': sizeMultiplier = 0.7; break;
      case 'medium': sizeMultiplier = 1.0; break;
      case 'large': sizeMultiplier = 1.4; break;
      case 'xlarge': sizeMultiplier = 1.8; break;
      default: sizeMultiplier = 1 + Math.log(node.metrics.requestRate + 1) / 10;
    }

    return Math.min(baseRadius * sizeMultiplier, 50);
  }

  static getNodeIcon(type: string): string {
    switch (type) {
      case 'service': return '‚öôÔ∏è';
      case 'database': return 'üóÑÔ∏è';
      case 'external': return 'üåê';
      case 'frontend': return 'üíª';
      case 'cache': return '‚ö°';
      case 'queue': return 'üìä';
      default: return '‚ùì';
    }
  }

  static createMarkers(defs: d3.Selection<SVGDefsElement, unknown, null, undefined>) {
    ['healthy', 'warning', 'critical'].forEach(status => {
      defs.append('marker')
        .attr('id', `arrow-${status}`)
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 25)
        .attr('refY', 0)
        .attr('markerWidth', 6)
        .attr('markerHeight', 6)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', this.getStatusColor(status));
    });
  }

  static createGradients(defs: d3.Selection<SVGDefsElement, unknown, null, undefined>) {
    const gradient = defs.append('radialGradient')
      .attr('id', 'nodeGradient')
      .attr('cx', '30%')
      .attr('cy', '30%');
    
    gradient.append('stop')
      .attr('offset', '0%')
      .attr('stop-color', 'rgba(255,255,255,0.3)');
    
    gradient.append('stop')
      .attr('offset', '100%')
      .attr('stop-color', 'rgba(0,0,0,0.1)');
  }

  static drawNode(
    group: d3.Selection<SVGGElement, D3Node, SVGGElement, unknown>,
    node: D3Node,
    theme: GrafanaTheme2
  ) {
    const radius = this.getNodeRadius(node);
    const shape = node.shape || 'circle';

    // Draw main shape
    if (shape === 'circle') {
      group.append('circle')
        .attr('r', radius)
        .attr('fill', node.color || this.getNodeColor(node.type))
        .attr('stroke', this.getStatusColor(node.status))
        .attr('stroke-width', node.pinned ? 4 : 3)
        .style('filter', 'url(#nodeGradient) drop-shadow(2px 2px 4px rgba(0,0,0,0.3))');
    } else if (shape === 'square') {
      group.append('rect')
        .attr('width', radius * 1.6)
        .attr('height', radius * 1.6)
        .attr('x', -radius * 0.8)
        .attr('y', -radius * 0.8)
        .attr('rx', 4)
        .attr('fill', node.color || this.getNodeColor(node.type))
        .attr('stroke', this.getStatusColor(node.status))
        .attr('stroke-width', node.pinned ? 4 : 3)
        .style('filter', 'url(#nodeGradient) drop-shadow(2px 2px 4px rgba(0,0,0,0.3))');
    } else if (shape === 'diamond') {
      group.append('polygon')
        .attr('points', `0,${-radius} ${radius},0 0,${radius} ${-radius},0`)
        .attr('fill', node.color || this.getNodeColor(node.type))
        .attr('stroke', this.getStatusColor(node.status))
        .attr('stroke-width', node.pinned ? 4 : 3)
        .style('filter', 'url(#nodeGradient) drop-shadow(2px 2px 4px rgba(0,0,0,0.3))');
    } else if (shape === 'triangle') {
      group.append('polygon')
        .attr('points', `0,${-radius} ${radius * 0.866},${radius * 0.5} ${-radius * 0.866},${radius * 0.5}`)
        .attr('fill', node.color || this.getNodeColor(node.type))
        .attr('stroke', this.getStatusColor(node.status))
        .attr('stroke-width', node.pinned ? 4 : 3)
        .style('filter', 'url(#nodeGradient) drop-shadow(2px 2px 4px rgba(0,0,0,0.3))');
    } else if (shape === 'hexagon') {
      const points = [];
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI) / 3;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        points.push(`${x},${y}`);
      }
      group.append('polygon')
        .attr('points', points.join(' '))
        .attr('fill', node.color || this.getNodeColor(node.type))
        .attr('stroke', this.getStatusColor(node.status))
        .attr('stroke-width', node.pinned ? 4 : 3)
        .style('filter', 'url(#nodeGradient) drop-shadow(2px 2px 4px rgba(0,0,0,0.3))');
    }

    // Add status indicator
    group.append('circle')
      .attr('class', 'status-indicator')
      .attr('r', 4)
      .attr('cx', radius - 8)
      .attr('cy', -radius + 8)
      .attr('fill', this.getStatusColor(node.status))
      .attr('stroke', theme.colors.background.primary)
      .attr('stroke-width', 1);

    // Add icon
    group.append('text')
      .attr('class', 'node-icon')
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'central')
      .attr('font-size', Math.min(radius / 2, 16) + 'px')
      .text(node.icon || this.getNodeIcon(node.type))
      .style('pointer-events', 'none')
      .style('user-select', 'none');

    // Add label
    const labelGroup = group.append('g').attr('class', 'label-group');
    
    labelGroup.append('rect')
      .attr('class', 'label-bg')
      .attr('rx', 2)
      .attr('ry', 2)
      .attr('fill', theme.colors.background.secondary)
      .attr('stroke', theme.colors.border.medium)
      .attr('stroke-width', 0.5)
      .style('opacity', 0.9);

    const labelText = labelGroup.append('text')
      .attr('class', 'node-label')
      .attr('text-anchor', 'middle')
      .attr('font-size', '11px')
      .attr('font-weight', 'bold')
      .attr('fill', theme.colors.text.primary)
      .text(node.name)
      .style('pointer-events', 'none')
      .style('user-select', 'none');

    // Position and size label background
    const bbox = (labelText.node() as SVGTextElement).getBBox();
    labelGroup.select('.label-bg')
      .attr('x', bbox.x - 4)
      .attr('y', bbox.y - 2)
      .attr('width', bbox.width + 8)
      .attr('height', bbox.height + 4);

    labelGroup.attr('transform', `translate(0, ${radius + 20})`);

    // Add metrics
    if (node.metrics) {
      group.append('text')
        .attr('class', 'node-metrics')
        .attr('text-anchor', 'middle')
        .attr('font-size', '9px')
        .attr('fill', theme.colors.text.secondary)
        .attr('dy', radius + 40)
        .text(`${node.metrics.latency}ms | ${node.metrics.errorRate.toFixed(1)}%`)
        .style('pointer-events', 'none')
        .style('user-select', 'none');
    }
  }

  static createDragBehavior(
    simulation: d3.Simulation<D3Node, D3Link>,
    onNodeUpdate?: (node: D3Node) => void
  ) {
    return d3.drag<SVGGElement, D3Node>()
      .on('start', function(event, d) {
        d.isDragging = true;
        d.dragStartTime = Date.now();
        d.originalPosition = { x: d.x!, y: d.y! };
        
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
        
        d3.select(this).classed('dragging', true).style('cursor', 'grabbing');
      })
      .on('drag', function(event, d) {
        d.fx = event.x;
        d.fy = event.y;
        
        if (onNodeUpdate) onNodeUpdate(d);
      })
      .on('end', function(event, d) {
        const dragDuration = Date.now() - (d.dragStartTime || 0);
        const dragDistance = Math.sqrt(
          Math.pow((d.x || 0) - (d.originalPosition?.x || 0), 2) +
          Math.pow((d.y || 0) - (d.originalPosition?.y || 0), 2)
        );
        
        d.isDragging = false;
        d.dragStartTime = undefined;
        
        const shouldPin = dragDuration > 500 || dragDistance > 50;
        if (shouldPin && !d.pinned) {
          d.pinned = true;
          d.locked = true;
        }
        
        if (!event.active) simulation.alphaTarget(0);
        
        if (!d.pinned) {
          d.fx = null;
          d.fy = null;
        }
        
        d3.select(this).classed('dragging', false).style('cursor', 'grab');
        d.originalPosition = undefined;
      });
  }

  static highlightConnections(
    nodeId: string,
    nodes: D3Node[],
    links: D3Link[],
    nodeSelection: any,
    linkSelection: any
  ) {
    const connectedNodeIds = new Set<string>();
    connectedNodeIds.add(nodeId);

    links.forEach(link => {
      if (link.source.id === nodeId || link.target.id === nodeId) {
        connectedNodeIds.add(link.source.id);
        connectedNodeIds.add(link.target.id);
      }
    // File: package.json
{
  "name": "grafana-scenes-d3-servicemap-app",
  "version": "1.0.0",
  "description": "Grafana Scenes App with D3.js Service Map - Enhanced Edition",
  "main": "dist/module.js",
  "scripts": {
    "build": "grafana-toolkit plugin:build",
    "dev": "grafana-toolkit plugin:dev",
    "test": "grafana-toolkit plugin:test",
    "sign": "grafana-toolkit plugin:sign",
    "clean": "rimraf dist coverage",
    "lint": "eslint src --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@grafana/data": "^10.0.0",
    "@grafana/runtime": "^10.0.0",
    "@grafana/scenes": "^4.0.0",
    "@grafana/ui": "^10.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "d3": "^7.8.5",
    "d3-force": "^3.0.0",
    "d3-selection": "^3.0.0",
    "d3-zoom": "^3.0.0",
    "d3-drag": "^3.0.0",
    "lodash": "^4.17.21",
    "@emotion/css": "^11.11.0"
  },
  "devDependencies": {
    "@grafana/toolkit": "^10.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/d3": "^7.4.0",
    "@types/lodash": "^4.14.0",
    "typescript": "^5.0.0",
    "eslint": "^8.0.0"
  }
}

// File: src/plugin.json
{
  "type": "app",
  "name": "Enhanced D3 Service Map",
  "id": "enhanced-d3-servicemap-app",
  "info": {
    "description": "Advanced service map visualization using D3.js and Grafana Scenes with drag controls and node customization",
    "author": {
      "name": "Service Map Team"
    },
    "keywords": ["scenes", "d3", "servicemap", "observability", "microservices"],
    "version": "1.0.0",
    "updated": "2025-01-01"
  },
  "includes": [
    {
      "type": "page",
      "name": "Enhanced Service Map",
      "path": "/a/enhanced-d3-servicemap-app",
      "role": "Viewer",
      "addToNav": true
    }
  ],
  "dependencies": {
    "grafanaVersion": "9.0.0"
  }
}

// File: src/module.ts
import { AppPlugin } from '@grafana/data';
import { AppConfig } from './types';
import { ServiceMapApp } from './components/ServiceMapApp';

export const plugin = new AppPlugin<AppConfig>().setRootPage(ServiceMapApp);

// File: src/types/index.ts
export interface AppConfig {
  apiUrl?: string;
  refreshInterval?: number;
}

export interface ServiceNode {
  id: string;
  name: string;
  type: 'service' | 'database' | 'external' | 'frontend' | 'cache' | 'queue';
  status: 'healthy' | 'warning' | 'critical' | 'unknown';
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
    cpu?: number;
    memory?: number;
  };
  // Enhanced node options
  size?: 'small' | 'medium' | 'large' | 'xlarge';
  shape?: 'circle' | 'square' | 'diamond' | 'hexagon' | 'triangle';
  color?: string;
  icon?: string;
  layer?: number;
  draggable?: boolean;
  pinned?: boolean;
  highlighted?: boolean;
  group?: string;
  metadata?: Record<string, any>;
  position?: { x: number; y: number };
}

export interface ServiceEdge {
  id: string;
  source: string | ServiceNode;
  target: string | ServiceNode;
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
  };
  status: 'healthy' | 'warning' | 'critical';
  value?: number;
}

export interface ServiceMapData {
  nodes: ServiceNode[];
  edges: ServiceEdge[];
  timestamp: number;
}

export interface D3Node extends ServiceNode {
  x?: number;
  y?: number;
  fx?: number | null;
  fy?: number | null;
  vx?: number;
  vy?: number;
  isDragging?: boolean;
  dragStartTime?: number;
  originalPosition?: { x: number; y: number };
  locked?: boolean;
  selected?: boolean;
}

export interface D3Link extends ServiceEdge {
  source: D3Node;
  target: D3Node;
}

export interface DragControlsState {
  dragMode: boolean;
  physicsEnabled: boolean;
  forceStrength: number;
  linkDistance: number;
}

export interface NodeOptionsState {
  selectedNodeId?: string;
  isVisible: boolean;
}

// File: src/components/ServiceMapApp.tsx
import React from 'react';
import { PluginPage } from '@grafana/runtime';
import { ServiceMapScene } from './ServiceMapScene';

export function ServiceMapApp() {
  return (
    <PluginPage>
      <ServiceMapScene />
    </PluginPage>
  );
}

// File: src/components/ServiceMapScene.tsx
import React, { useMemo } from 'react';
import {
  SceneApp,
  SceneAppPage,
  SceneFlexLayout,
  SceneFlexItem,
  EmbeddedScene,
  SceneControlsSpacer,
  SceneRefreshPicker,
  SceneTimePicker,
  VariableValueSelectors,
} from '@grafana/scenes';
import { EnhancedServiceMapVisualization } from './EnhancedServiceMapVisualization';
import { ServiceMapDataProvider } from '../data/ServiceMapDataProvider';

export function ServiceMapScene() {
  const scene = useMemo(() => {
    const dataProvider = new ServiceMapDataProvider();

    return new SceneApp({
      pages: [
        new SceneAppPage({
          title: 'Enhanced D3 Service Map',
          url: '/enhanced-servicemap',
          getScene: () => {
            return new EmbeddedScene({
              controls: [
                new VariableValueSelectors({}),
                new SceneControlsSpacer(),
                new SceneTimePicker({ isOnCanvas: true }),
                new SceneRefreshPicker({
                  intervals: ['5s', '10s', '30s', '1m', '5m', '15m'],
                  isOnCanvas: true,
                }),
              ],
              body: new SceneFlexLayout({
                direction: 'column',
                children: [
                  new SceneFlexItem({
                    minHeight: 700,
                    body: new EnhancedServiceMapVisualization({
                      dataProvider,
                    }),
                  }),
                ],
              }),
            });
          },
        }),
      ],
    });
  }, []);

  return <scene.Component model={scene} />;
}

// File: src/components/EnhancedServiceMapVisualization.tsx
import React, { useEffect, useRef, useState, useCallback } from 'react';
import { SceneComponentProps, SceneObjectBase, SceneObjectState } from '@grafana/scenes';
import { ServiceMapData, D3Node, ServiceNode, DragControlsState, NodeOptionsState } from '../types';
import { ServiceMapDataProvider } from '../data/ServiceMapDataProvider';
import { useStyles2, useTheme2 } from '@grafana/ui';
import { getStyles } from '../styles/serviceMapStyles';
import { D3ServiceMapRenderer } from './D3ServiceMapRenderer';
import { ServiceNodeDetails } from './ServiceNodeDetails';
import { ServiceMapLegend } from './ServiceMapLegend';
import { NodeOptionsPanel } from './NodeOptionsPanel';
import { DragControls } from './DragControls';

interface EnhancedServiceMapVisualizationState extends SceneObjectState {
  data?: ServiceMapData;
  selectedNode?: string;
  loading: boolean;
  dragControls: DragControlsState;
  nodeOptions: NodeOptionsState;
}

interface EnhancedServiceMapVisualizationProps {
  dataProvider: ServiceMapDataProvider;
}

export class EnhancedServiceMapVisualization extends SceneObjectBase<EnhancedServiceMapVisualizationState> {
  private dataProvider: ServiceMapDataProvider;

  constructor(props: EnhancedServiceMapVisualizationProps) {
    super({
      loading: true,
      dragControls: {
        dragMode: true,
        physicsEnabled: true,
        forceStrength: 300,
        linkDistance: 120,
      },
      nodeOptions: {
        isVisible: false,
      },
    });
    this.dataProvider = props.dataProvider;
  }

  public static Component = ({ model }: SceneComponentProps<EnhancedServiceMapVisualization>) => {
    const { data, loading, selectedNode, dragControls, nodeOptions } = model.useState();
    const theme = useTheme2();
    const styles = useStyles2(getStyles);

    // Load data
    useEffect(() => {
      model.dataProvider.getData().then((serviceMapData) => {
        model.setState({ data: serviceMapData, loading: false });
      });

      const interval = setInterval(() => {
        model.dataProvider.getData().then((serviceMapData) => {
          model.setState({ data: serviceMapData });
        });
      }, 10000);

      return () => clearInterval(interval);
    }, [model]);

    // Event handlers
    const handleNodeClick = useCallback((nodeId: string) => {
      model.setState({ selectedNode: nodeId });
    }, [model]);

    const handleBackgroundClick = useCallback(() => {
      model.setState({ 
        selectedNode: undefined,
        nodeOptions: { ...nodeOptions, isVisible: false }
      });
    }, [model, nodeOptions]);

    const handleNodeUpdate = useCallback((nodeId: string, updates: Partial<ServiceNode>) => {
      if (!data) return;
      
      const updatedNodes = data.nodes.map(node => 
        node.id === nodeId ? { ...node, ...updates } : node
      );
      
      model.setState({
        data: { ...data, nodes: updatedNodes },
        nodeOptions: { ...nodeOptions, isVisible: false },
      });
    }, [data, model, nodeOptions]);

    const handleShowNodeOptions = useCallback(() => {
      model.setState({
        nodeOptions: { 
          selectedNodeId: selectedNode,
          isVisible: true 
        }
      });
    }, [model, selectedNode]);

    const handleDragControlsChange = useCallback((updates: Partial<DragControlsState>) => {
      model.setState({
        dragControls: { ...dragControls, ...updates }
      });
    }, [model, dragControls]);

    if (loading) {
      return <div className={styles.loading}>Loading enhanced service map...</div>;
    }

    if (!data) {
      return <div className={styles.loading}>No data available</div>;
    }

    return (
      <div className={styles.container}>
        <D3ServiceMapRenderer
          data={data}
          theme={theme}
          dragControls={dragControls}
          onNodeClick={handleNodeClick}
          onBackgroundClick={handleBackgroundClick}
          onNodeUpdate={(node) => console.log('Node updated:', node)}
        />
        
        <DragControls
          controls={dragControls}
          onChange={handleDragControlsChange}
        />

        <div className={styles.topControls}>
          <button 
            className={styles.controlButton}
            onClick={() => {
              // Reset zoom - this would be handled in D3ServiceMapRenderer
              console.log('Reset zoom');
            }}
          >
            Reset View
          </button>
          
          {selectedNode && (
            <button 
              className={styles.controlButton}
              onClick={handleShowNodeOptions}
            >
              Node Options
            </button>
          )}
        </div>

        <ServiceMapLegend />

        {selectedNode && data && !nodeOptions.isVisible && (
          <ServiceNodeDetails
            node={data.nodes.find(n => n.id === selectedNode)}
            onClose={() => model.setState({ selectedNode: undefined })}
          />
        )}

        {nodeOptions.isVisible && selectedNode && data && (
          <NodeOptionsPanel
            selectedNode={data.nodes.find(n => n.id === selectedNode)}
            onNodeUpdate={handleNodeUpdate}
            onClose={() => model.setState({ 
              nodeOptions: { ...nodeOptions, isVisible: false }
            })}
          />
        )}
      </div>
    );
  };
}

// File: src/components/D3ServiceMapRenderer.tsx
import React, { useEffect, useRef } from 'react';
import * as d3 from 'd3';
import { ServiceMapData, D3Node, D3Link, DragControlsState } from '../types';
import { GrafanaTheme2 } from '@grafana/data';
import { D3Utils } from '../utils/d3Utils';

interface D3ServiceMapRendererProps {
  data: ServiceMapData;
  theme: GrafanaTheme2;
  dragControls: DragControlsState;
  onNodeClick: (nodeId: string) => void;
  onBackgroundClick: () => void;
  onNodeUpdate: (node: D3Node) => void;
}

export const D3ServiceMapRenderer: React.FC<D3ServiceMapRendererProps> = ({
  data,
  theme,
  dragControls,
  onNodeClick,
  onBackgroundClick,
  onNodeUpdate,
}) => {
  const svgRef = useRef<SVGSVGElement>(null);
  const simulationRef = useRef<d3.Simulation<D3Node, D3Link> | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!data || !svgRef.current || !containerRef.current) return;

    const svg = d3.select(svgRef.current);
    const container = containerRef.current;
    const width = container.clientWidth;
    const height = container.clientHeight;

    // Clear previous content
    svg.selectAll('*').remove();

    // Create main group
    const g = svg.append('g').attr('class', 'main-group');

    // Setup zoom
    const zoom = d3.zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 5])
      .on('zoom', (event) => {
        g.attr('transform', event.transform);
      });

    svg.call(zoom);

    // Prepare data
    const nodes: D3Node[] = data.nodes.map(d => ({ 
      ...d,
      selected: false,
      isDragging: false,
    }));
    
    const links: D3Link[] = data.edges.map(d => ({
      ...d,
      source: nodes.find(n => n.id === (typeof d.source === 'string' ? d.source : d.source.id))!,
      target: nodes.find(n => n.id === (typeof d.target === 'string' ? d.target : d.target.id))!,
      value: d.metrics.requestRate,
    }));

    // Create simulation
    const simulation = d3.forceSimulation<D3Node>(nodes)
      .force('link', d3.forceLink<D3Node, D3Link>(links)
        .id(d => d.id)
        .distance(dragControls.linkDistance)
        .strength(0.8)
      )
      .force('charge', d3.forceManyBody()
        .strength(-dragControls.forceStrength)
      )
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collision', d3.forceCollide()
        .radius(d => D3Utils.getNodeRadius(d) + 10)
        .strength(0.9)
      );

    simulationRef.current = simulation;

    // Create defs for markers and gradients
    const defs = svg.append('defs');
    D3Utils.createMarkers(defs);
    D3Utils.createGradients(defs);

    // Create links
    const linkGroup = g.append('g').attr('class', 'links');
    const link = linkGroup.selectAll('line')
      .data(links)
      .enter().append('line')
      .attr('class', 'link')
      .attr('stroke', d => D3Utils.getStatusColor(d.status))
      .attr('stroke-width', d => Math.max(2, Math.sqrt(d.value || 1) / 3))
      .attr('marker-end', d => `url(#arrow-${d.status})`)
      .style('opacity', 0.7);

    // Create nodes
    const nodeGroup = g.append('g').attr('class', 'nodes');
    const nodeGroups = nodeGroup.selectAll('g')
      .data(nodes)
      .enter().append('g')
      .attr('class', d => `node node-${d.type}`)
      .style('cursor', d => d.draggable !== false ? 'grab' : 'default');

    // Add node shapes
    nodeGroups.each(function(d) {
      const group = d3.select(this);
      D3Utils.drawNode(group, d, theme);
    });

    // Add drag behavior
    if (dragControls.dragMode) {
      const drag = D3Utils.createDragBehavior(simulation, onNodeUpdate);
      nodeGroups
        .filter(d => d.draggable !== false)
        .call(drag);
    }

    // Add click handlers
    nodeGroups.on('click', (event, d) => {
      event.stopPropagation();
      onNodeClick(d.id);
      D3Utils.highlightConnections(d.id, nodes, links, nodeGroups, link);
    });

    nodeGroups.on('dblclick', (event, d) => {
      event.stopPropagation();
      if (d.draggable !== false) {
        d.pinned = !d.pinned;
        if (d.pinned) {
          d.fx = d.x;
          d.fy = d.y;
        } else {
          d.fx = null;
          d.fy = null;
        }
        simulation.alphaTarget(0.1).restart();
      }
    });

    svg.on('click', (event) => {
      if (event.target === svg.node()) {
        onBackgroundClick();
        D3Utils.clearHighlights(nodeGroups, link);
      }
    });

    // Simulation tick
    simulation.on('tick', () => {
      link
        .attr('x1', d => d.source.x!)
        .attr('y1', d => d.source.y!)
        .attr('x2', d => d.target.x!)
        .attr('y2', d => d.target.y!);

      nodeGroups.attr('transform', d => `translate(${d.x},${d.y})`);
    });

    // Control physics
    if (!dragControls.physicsEnabled) {
      simulation.stop();
    }

    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop();
      }
    };
  }, [data, theme, dragControls, onNodeClick, onBackgroundClick, onNodeUpdate]);

  // Update simulation forces when controls change
  useEffect(() => {
    if (simulationRef.current) {
      simulationRef.current
        .force('charge', d3.forceManyBody().strength(-dragControls.forceStrength))
        .force('link', d3.forceLink().distance(dragControls.linkDistance))
        .alphaTarget(0.1)
        .restart();
    }
  }, [dragControls.forceStrength, dragControls.linkDistance]);

  return (
    <div ref={containerRef} style={{ width: '100%', height: '100%' }}>
      <svg
        ref={svgRef}
        width="100%"
        height="100%"
        style={{ background: 'transparent' }}
      />
    </div>
  );
};

// File: src/components/DragControls.tsx
import React from 'react';
import { Button, Switch, Slider } from '@grafana/ui';
import { css } from '@emotion/css';
import { GrafanaTheme2 } from '@grafana/data';
import { useStyles2 } from '@grafana/ui';
import { DragControlsState } from '../types';

interface DragControlsProps {
  controls: DragControlsState;
  onChange: (updates: Partial<DragControlsState>) => void;
}

const getControlStyles = (theme: GrafanaTheme2) => ({
  panel: css`
    position: absolute;
    top: ${theme.spacing(2)};
    left: ${theme.spacing(2)};
    background: ${theme.colors.background.secondary};
    border: 1px solid ${theme.colors.border.medium};
    border-radius: ${theme.shape.borderRadius()};
    padding: ${theme.spacing(2)};
    z-index: 1000;
    min-width: 220px;
  `,
  title: css`
    font-size: ${theme.typography.h6.fontSize};
    font-weight: ${theme.typography.fontWeightMedium};
    margin-bottom: ${theme.spacing(2)};
    color: ${theme.colors.text.primary};
  `,
  section: css`
    margin-bottom: ${theme.spacing(2)};
  `,
  field: css`
    margin-bottom: ${theme.spacing(1.5)};
  `,
  label: css`
    font-size: ${theme.typography.bodySmall.fontSize};
    color: ${theme.colors.text.secondary};
    margin-bottom: ${theme.spacing(0.5)};
    display: block;
  `,
});

export const DragControls: React.FC<DragControlsProps> = ({ controls, onChange }) => {
  const styles = useStyles2(getControlStyles);

  return (
    <div className={styles.panel}>
      <div className={styles.title}>Controls</div>
      
      <div className={styles.section}>
        <div className={styles.field}>
          <Switch
            label="Enable Dragging"
            value={controls.dragMode}
            onChange={(checked) => onChange({ dragMode: checked })}
          />
        </div>

        <div className={styles.field}>
          <Switch
            label="Physics Simulation"
            value={controls.physicsEnabled}
            onChange={(checked) => onChange({ physicsEnabled: checked })}
          />
        </div>
      </div>

      {controls.physicsEnabled && (
        <div className={styles.section}>
          <div className={styles.field}>
            <label className={styles.label}>
              Force Strength: {controls.forceStrength}
            </label>
            <Slider
              min={50}
              max={1000}
              step={10}
              value={controls.forceStrength}
              onChange={(value) => onChange({ forceStrength: value })}
            />
          </div>

          <div className={styles.field}>
            <label className={styles.label}>
              Link Distance: {controls.linkDistance}
            </label>
            <Slider
              min={50}
              max={300}
              step={5}
              value={controls.linkDistance}
              onChange={(value) => onChange({ linkDistance: value })}
            />
          </div>
        </div>
      )}
    </div>
  );
};

// File: src/components/NodeOptionsPanel.tsx
import React, { useState } from 'react';
import { ServiceNode } from '../types';
import { Button, Input, Select, Switch } from '@grafana/ui';
import { css } from '@emotion/css';
import { GrafanaTheme2 } from '@grafana/data';
import { useStyles2 } from '@grafana/ui';

interface NodeOptionsPanelProps {
  selectedNode?: ServiceNode;
  onNodeUpdate: (nodeId: string, updates: Partial<ServiceNode>) => void;
  onClose: () => void;
}

const getOptionStyles = (theme: GrafanaTheme2) => ({
  panel: css`
    position: fixed;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
    width: 320px;
    max-height: 80vh;
    overflow-y: auto;
    background: ${theme.colors.background.primary};
    border: 1px solid ${theme.colors.border.medium};
    border-radius: ${theme.shape.borderRadius()};
    padding: ${theme.spacing(3)};
    z-index: 1001;
    box-shadow: ${theme.shadows.z3};
  `,
  title: css`
    font-size: ${theme.typography.h5.fontSize};
    font-weight: ${theme.typography.fontWeightMedium};
    margin-bottom: ${theme.spacing(3)};
    color: ${theme.colors.text.primary};
  `,
  section: css`
    margin-bottom: ${theme.spacing(3)};
  `,
  sectionTitle: css`
    font-size: ${theme.typography.h6.fontSize};
    font-weight: ${theme.typography.fontWeightMedium};
    margin-bottom: ${theme.spacing(2)};
    color: ${theme.colors.text.primary};
  `,
  field: css`
    margin-bottom: ${theme.spacing(2)};
  `,
  fieldLabel: css`
    display: block;
    font-size: ${theme.typography.bodySmall.fontSize};
    font-weight: ${theme.typography.fontWeightMedium};
    margin-bottom: ${theme.spacing(1)};
    color: ${theme.colors.text.secondary};
  `,
  buttonGroup: css`
    display: flex;
    gap: ${theme.spacing(1)};
    margin-top: ${theme.spacing(3)};
  `,
});

export const NodeOptionsPanel: React.FC<NodeOptionsPanelProps> = ({
  selectedNode,
  onNodeUpdate,
  onClose,
}) => {
  const styles = useStyles2(getOptionStyles);
  const [localUpdates, setLocalUpdates] = useState<Partial<ServiceNode>>({});

  if (!selectedNode) return null;

  const currentNode = { ...selectedNode, ...localUpdates };

  const handleUpdate = (key: keyof ServiceNode, value: any) => {
    setLocalUpdates(prev => ({ ...prev, [key]: value }));
  };

  const applyChanges = () => {
    onNodeUpdate(selectedNode.id, localUpdates);
    setLocalUpdates({});
    onClose();
  };

  const sizeOptions = [
    { label: 'Small', value: 'small' },
    { label: 'Medium', value: 'medium' },
    { label: 'Large', value: 'large' },
    { label: 'Extra Large', value: 'xlarge' },
  ];

  const shapeOptions = [
    { label: 'Circle', value: 'circle' },
    { label: 'Square', value: 'square' },
    { label: 'Diamond', value: 'diamond' },
    { label: 'Hexagon', value: 'hexagon' },
    { label: 'Triangle', value: 'triangle' },
  ];

  const groupOptions = [
    { label: 'None', value: '' },
    { label: 'Frontend', value: 'frontend' },
    { label: 'Backend', value: 'backend' },
    { label: 'Data', value: 'data' },
    { label: 'Infrastructure', value: 'infrastructure' },
    { label: 'External', value: 'external' },
  ];

  return (
    <div className={styles.panel}>
      <div className={styles.title}>Node Options</div>
      
      <div className={styles.section}>
        <div className={styles.sectionTitle}>{selectedNode.name}</div>
        
        <div className={styles.field}>
          <label className={styles.fieldLabel}>Name</label>
          <Input
            value={currentNode.name || ''}
            onChange={(e) => handleUpdate('name', e.currentTarget.value)}
          />
        </div>

        <div className={styles.field}>
          <label className={styles.fieldLabel}>Size</label>
          <Select
            value={currentNode.size || 'medium'}
            options={sizeOptions}
            onChange={(option) => handleUpdate('size', option.value)}
          />
        </div>

        <div className={styles.field}>
          <label className={styles.fieldLabel}>Shape</label>
          <Select
            value={currentNode.shape || 'circle'}
            options={shapeOptions}
            onChange={(option) => handleUpdate('shape', option.value)}
          />
        </div>

        <div className={styles.field}>
          <label className={styles.fieldLabel}>Group</label>
          <Select
            value={currentNode.group || ''}
            options={groupOptions}
            onChange={(option) => handleUpdate('group', option.value)}
          />
        </div>
      </div>

      <div className={styles.section}>
        <div className={styles.sectionTitle}>Behavior</div>
        
        <div className={styles.field}>
          <Switch
            label="Draggable"
            value={currentNode.draggable !== false}
            onChange={(checked) => handleUpdate('draggable', checked)}
          />
        </div>

        <div className={styles.field}>
          <Switch
            label="Pinned"
            value={currentNode.pinned || false}
            onChange={(checked) => handleUpdate('pinned', checked)}
          />
        </div>

        <div className={styles.field}>
          <Switch
            label="Highlighted"
            value={currentNode.highlighted || false}
            onChange={(checked) => handleUpdate('highlighted', checked)}
          />
        </div>
      </div>

      <div className={styles.section}>
        <div className={styles.sectionTitle}>Appearance</div>
        
        <div className={styles.field}>
          <label className={styles.fieldLabel}>Custom Color</label>
          <Input
            type="color"
            value={currentNode.color || '#1f77b4'}
            onChange={(e) => handleUpdate('color', e.currentTarget.value)}
          />
        </div>

        <div className={styles.field}>
          <label className={styles.fieldLabel}>Icon</label>
          <Input
            value={currentNode.icon || ''}
            onChange={(e) => handleUpdate('icon', e.currentTarget.value)}
            placeholder="Enter emoji"
            maxLength={2}
          />
        </div>
      </div>
