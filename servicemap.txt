// Project Structure:
/*
grafana-scenes-servicemap/
├── package.json
├── tsconfig.json
├── webpack.config.js
├── src/
│   ├── index.ts
│   ├── types/
│   │   ├── index.ts
│   │   ├── service.types.ts
│   │   └── graph.types.ts
│   ├── components/
│   │   ├── ServiceMapScene.ts
│   │   ├── ServiceMapPanel.ts
│   │   └── ServiceMapRenderer.ts
│   ├── services/
│   │   ├── DataService.ts
│   │   └── GraphService.ts
│   ├── utils/
│   │   ├── graphUtils.ts
│   │   └── colorUtils.ts
│   └── styles/
│       └── servicemap.css
├── dist/
└── README.md
*/

// ============= package.json =============
{
  "name": "grafana-scenes-servicemap",
  "version": "1.0.0",
  "description": "Custom Grafana Scenes ServiceMap Graph Application",
  "main": "dist/index.js",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack --mode development --watch",
    "start": "webpack serve --mode development",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@grafana/scenes": "^4.0.0",
    "@grafana/data": "^10.0.0",
    "@grafana/ui": "^10.0.0",
    "@grafana/runtime": "^10.0.0",
    "d3": "^7.8.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@types/d3": "^7.4.0",
    "@types/node": "^20.0.0",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "css-loader": "^6.8.1",
    "style-loader": "^3.3.3",
    "ts-loader": "^9.4.4",
    "typescript": "^5.1.6",
    "webpack": "^5.88.2",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1"
  }
}

// ============= tsconfig.json =============
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "ESNext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"],
      "@/types/*": ["types/*"],
      "@/components/*": ["components/*"],
      "@/services/*": ["services/*"],
      "@/utils/*": ["utils/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}

// ============= webpack.config.js =============
const path = require('path');

module.exports = {
  entry: './src/index.ts',
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
      },
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
  resolve: {
    extensions: ['.tsx', '.ts', '.js'],
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
    clean: true,
  },
  externals: {
    '@grafana/scenes': '@grafana/scenes',
    '@grafana/data': '@grafana/data',
    '@grafana/ui': '@grafana/ui',
    '@grafana/runtime': '@grafana/runtime',
    'react': 'react',
    'react-dom': 'react-dom',
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'),
    compress: true,
    port: 9000,
  },
};

// ============= src/types/index.ts =============
export * from './service.types';
export * from './graph.types';

// ============= src/types/service.types.ts =============
export interface ServiceNode {
  id: string;
  name: string;
  type: 'service' | 'database' | 'external' | 'frontend';
  status: 'healthy' | 'warning' | 'critical' | 'unknown';
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
    cpu: number;
    memory: number;
  };
  metadata: {
    version?: string;
    namespace?: string;
    cluster?: string;
    environment?: string;
  };
  position?: {
    x: number;
    y: number;
  };
}

export interface ServiceEdge {
  id: string;
  source: string;
  target: string;
  type: 'http' | 'grpc' | 'database' | 'message_queue';
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
    throughput: number;
  };
  status: 'healthy' | 'warning' | 'critical';
  protocol?: string;
}

export interface ServiceMapData {
  nodes: ServiceNode[];
  edges: ServiceEdge[];
  timestamp: number;
}

// ============= src/types/graph.types.ts =============
import { ServiceNode, ServiceEdge } from './service.types';

export interface GraphLayout {
  width: number;
  height: number;
  padding: number;
}

export interface GraphConfig {
  layout: GraphLayout;
  simulation: {
    forceStrength: number;
    linkDistance: number;
    chargeStrength: number;
    centerStrength: number;
  };
  visual: {
    nodeRadius: number;
    strokeWidth: number;
    fontSize: number;
    colors: {
      [key: string]: string;
    };
  };
}

export interface D3Node extends ServiceNode {
  x?: number;
  y?: number;
  fx?: number | null;
  fy?: number | null;
  vx?: number;
  vy?: number;
}

export interface D3Edge extends ServiceEdge {
  source: D3Node | string;
  target: D3Node | string;
}

export interface GraphSelection {
  selectedNodes: string[];
  selectedEdges: string[];
  hoveredNode?: string;
  hoveredEdge?: string;
}

// ============= src/services/DataService.ts =============
import { ServiceMapData, ServiceNode, ServiceEdge } from '@/types';

export class DataService {
  private static instance: DataService;
  private mockData: ServiceMapData;

  private constructor() {
    this.mockData = this.generateMockData();
  }

  public static getInstance(): DataService {
    if (!DataService.instance) {
      DataService.instance = new DataService();
    }
    return DataService.instance;
  }

  public async fetchServiceMapData(): Promise<ServiceMapData> {
    // Simulate API call delay
    await new Promise(resolve => setTimeout(resolve, 500));
    return this.mockData;
  }

  public async updateServiceData(serviceId: string, updates: Partial<ServiceNode>): Promise<void> {
    const nodeIndex = this.mockData.nodes.findIndex(node => node.id === serviceId);
    if (nodeIndex !== -1) {
      this.mockData.nodes[nodeIndex] = { ...this.mockData.nodes[nodeIndex], ...updates };
    }
  }

  private generateMockData(): ServiceMapData {
    const nodes: ServiceNode[] = [
      {
        id: 'frontend',
        name: 'Frontend App',
        type: 'frontend',
        status: 'healthy',
        metrics: { requestRate: 1200, errorRate: 0.02, latency: 45, cpu: 25, memory: 512 },
        metadata: { version: '1.2.3', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'api-gateway',
        name: 'API Gateway',
        type: 'service',
        status: 'healthy',
        metrics: { requestRate: 1100, errorRate: 0.01, latency: 12, cpu: 35, memory: 256 },
        metadata: { version: '2.1.0', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'user-service',
        name: 'User Service',
        type: 'service',
        status: 'warning',
        metrics: { requestRate: 800, errorRate: 0.05, latency: 78, cpu: 65, memory: 1024 },
        metadata: { version: '1.5.2', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'order-service',
        name: 'Order Service',
        type: 'service',
        status: 'healthy',
        metrics: { requestRate: 450, errorRate: 0.01, latency: 32, cpu: 22, memory: 512 },
        metadata: { version: '3.0.1', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'payment-service',
        name: 'Payment Service',
        type: 'service',
        status: 'critical',
        metrics: { requestRate: 200, errorRate: 0.15, latency: 250, cpu: 85, memory: 768 },
        metadata: { version: '1.8.4', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'postgres-db',
        name: 'PostgreSQL',
        type: 'database',
        status: 'healthy',
        metrics: { requestRate: 2000, errorRate: 0.001, latency: 8, cpu: 45, memory: 2048 },
        metadata: { version: '14.5', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'redis-cache',
        name: 'Redis Cache',
        type: 'database',
        status: 'healthy',
        metrics: { requestRate: 1500, errorRate: 0.002, latency: 2, cpu: 15, memory: 256 },
        metadata: { version: '7.0', namespace: 'production', environment: 'prod' }
      },
      {
        id: 'external-payment',
        name: 'External Payment API',
        type: 'external',
        status: 'warning',
        metrics: { requestRate: 180, errorRate: 0.08, latency: 180, cpu: 0, memory: 0 },
        metadata: { environment: 'external' }
      }
    ];

    const edges: ServiceEdge[] = [
      {
        id: 'frontend-api-gateway',
        source: 'frontend',
        target: 'api-gateway',
        type: 'http',
        metrics: { requestRate: 1100, errorRate: 0.015, latency: 25, throughput: 15.2 },
        status: 'healthy',
        protocol: 'HTTPS'
      },
      {
        id: 'api-gateway-user-service',
        source: 'api-gateway',
        target: 'user-service',
        type: 'grpc',
        metrics: { requestRate: 600, errorRate: 0.02, latency: 15, throughput: 8.5 },
        status: 'healthy',
        protocol: 'gRPC'
      },
      {
        id: 'api-gateway-order-service',
        source: 'api-gateway',
        target: 'order-service',
        type: 'grpc',
        metrics: { requestRate: 400, errorRate: 0.01, latency: 12, throughput: 5.2 },
        status: 'healthy',
        protocol: 'gRPC'
      },
      {
        id: 'order-service-payment-service',
        source: 'order-service',
        target: 'payment-service',
        type: 'http',
        metrics: { requestRate: 180, errorRate: 0.08, latency: 45, throughput: 2.1 },
        status: 'warning',
        protocol: 'HTTP'
      },
      {
        id: 'user-service-postgres',
        source: 'user-service',
        target: 'postgres-db',
        type: 'database',
        metrics: { requestRate: 1200, errorRate: 0.001, latency: 5, throughput: 12.8 },
        status: 'healthy',
        protocol: 'PostgreSQL'
      },
      {
        id: 'order-service-postgres',
        source: 'order-service',
        target: 'postgres-db',
        type: 'database',
        metrics: { requestRate: 800, errorRate: 0.002, latency: 6, throughput: 8.9 },
        status: 'healthy',
        protocol: 'PostgreSQL'
      },
      {
        id: 'api-gateway-redis',
        source: 'api-gateway',
        target: 'redis-cache',
        type: 'database',
        metrics: { requestRate: 1500, errorRate: 0.001, latency: 1, throughput: 18.2 },
        status: 'healthy',
        protocol: 'Redis'
      },
      {
        id: 'payment-service-external',
        source: 'payment-service',
        target: 'external-payment',
        type: 'http',
        metrics: { requestRate: 180, errorRate: 0.12, latency: 200, throughput: 1.8 },
        status: 'critical',
        protocol: 'HTTPS'
      }
    ];

    return {
      nodes,
      edges,
      timestamp: Date.now()
    };
  }
}

// ============= src/services/GraphService.ts =============
import * as d3 from 'd3';
import { ServiceMapData, ServiceNode, ServiceEdge, GraphConfig, D3Node, D3Edge } from '@/types';

export class GraphService {
  private config: GraphConfig;
  private simulation: d3.Simulation<D3Node, D3Edge> | null = null;

  constructor(config: GraphConfig) {
    this.config = config;
  }

  public createSimulation(nodes: D3Node[], edges: D3Edge[]): d3.Simulation<D3Node, D3Edge> {
    const { width, height } = this.config.layout;
    const { forceStrength, linkDistance, chargeStrength, centerStrength } = this.config.simulation;

    this.simulation = d3.forceSimulation<D3Node>(nodes)
      .force('link', d3.forceLink<D3Node, D3Edge>(edges)
        .id(d => d.id)
        .distance(linkDistance)
        .strength(forceStrength))
      .force('charge', d3.forceManyBody().strength(chargeStrength))
      .force('center', d3.forceCenter(width / 2, height / 2).strength(centerStrength))
      .force('collision', d3.forceCollide(this.config.visual.nodeRadius + 10));

    return this.simulation;
  }

  public updateSimulation(nodes: D3Node[], edges: D3Edge[]): void {
    if (!this.simulation) return;

    this.simulation.nodes(nodes);
    const linkForce = this.simulation.force('link') as d3.ForceLink<D3Node, D3Edge>;
    if (linkForce) {
      linkForce.links(edges);
    }
    this.simulation.alpha(0.3).restart();
  }

  public getNodeColor(node: ServiceNode): string {
    const statusColors = {
      healthy: '#28a745',
      warning: '#ffc107',
      critical: '#dc3545',
      unknown: '#6c757d'
    };

    const typeColors = {
      service: '#007bff',
      database: '#17a2b8',
      external: '#6f42c1',
      frontend: '#fd7e14'
    };

    return node.status === 'healthy' ? typeColors[node.type] || '#6c757d' : statusColors[node.status];
  }

  public getEdgeColor(edge: ServiceEdge): string {
    const statusColors = {
      healthy: '#28a745',
      warning: '#ffc107',
      critical: '#dc3545'
    };
    return statusColors[edge.status] || '#6c757d';
  }

  public getEdgeWidth(edge: ServiceEdge): number {
    const baseWidth = 2;
    const maxWidth = 8;
    const maxRequestRate = 2000; // Adjust based on your data range
    
    return Math.max(baseWidth, Math.min(maxWidth, (edge.metrics.requestRate / maxRequestRate) * maxWidth));
  }

  public calculateNodeMetrics(node: ServiceNode): { x: number; y: number; radius: number } {
    const baseRadius = this.config.visual.nodeRadius;
    const cpuFactor = node.metrics.cpu / 100;
    const radius = baseRadius + (cpuFactor * 10);

    return {
      x: node.position?.x || 0,
      y: node.position?.y || 0,
      radius: Math.min(radius, baseRadius * 2)
    };
  }

  public stopSimulation(): void {
    if (this.simulation) {
      this.simulation.stop();
    }
  }

  public restartSimulation(): void {
    if (this.simulation) {
      this.simulation.alpha(0.3).restart();
    }
  }
}

// ============= src/utils/graphUtils.ts =============
import { ServiceNode, ServiceEdge } from '@/types';

export const formatMetric = (value: number, unit: string): string => {
  if (value >= 1000000) {
    return `${(value / 1000000).toFixed(1)}M${unit}`;
  } else if (value >= 1000) {
    return `${(value / 1000).toFixed(1)}K${unit}`;
  }
  return `${value}${unit}`;
};

export const formatLatency = (latency: number): string => {
  if (latency >= 1000) {
    return `${(latency / 1000).toFixed(2)}s`;
  }
  return `${latency}ms`;
};

export const formatPercentage = (value: number): string => {
  return `${(value * 100).toFixed(2)}%`;
};

export const getNodeTooltipContent = (node: ServiceNode): string => {
  return `
    <div class="tooltip-content">
      <h4>${node.name}</h4>
      <p><strong>Type:</strong> ${node.type}</p>
      <p><strong>Status:</strong> ${node.status}</p>
      <p><strong>Request Rate:</strong> ${formatMetric(node.metrics.requestRate, 'req/s')}</p>
      <p><strong>Error Rate:</strong> ${formatPercentage(node.metrics.errorRate)}</p>
      <p><strong>Latency:</strong> ${formatLatency(node.metrics.latency)}</p>
      <p><strong>CPU:</strong> ${node.metrics.cpu}%</p>
      <p><strong>Memory:</strong> ${formatMetric(node.metrics.memory, 'MB')}</p>
      ${node.metadata.version ? `<p><strong>Version:</strong> ${node.metadata.version}</p>` : ''}
    </div>
  `;
};

export const getEdgeTooltipContent = (edge: ServiceEdge): string => {
  return `
    <div class="tooltip-content">
      <h4>${edge.source} → ${edge.target}</h4>
      <p><strong>Type:</strong> ${edge.type}</p>
      <p><strong>Protocol:</strong> ${edge.protocol || 'Unknown'}</p>
      <p><strong>Status:</strong> ${edge.status}</p>
      <p><strong>Request Rate:</strong> ${formatMetric(edge.metrics.requestRate, 'req/s')}</p>
      <p><strong>Error Rate:</strong> ${formatPercentage(edge.metrics.errorRate)}</p>
      <p><strong>Latency:</strong> ${formatLatency(edge.metrics.latency)}</p>
      <p><strong>Throughput:</strong> ${edge.metrics.throughput} MB/s</p>
    </div>
  `;
};

export const filterNodesByStatus = (nodes: ServiceNode[], status: string[]): ServiceNode[] => {
  return nodes.filter(node => status.includes(node.status));
};

export const filterNodesByType = (nodes: ServiceNode[], types: string[]): ServiceNode[] => {
  return nodes.filter(node => types.includes(node.type));
};

export const findCriticalPath = (nodes: ServiceNode[], edges: ServiceEdge[]): string[] => {
  // Simple implementation - find path with highest error rates
  const criticalNodes = nodes
    .filter(node => node.status === 'critical' || node.metrics.errorRate > 0.1)
    .map(node => node.id);
  
  return criticalNodes;
};

// ============= src/utils/colorUtils.ts =============
export const getStatusColor = (status: string): string => {
  const colors: { [key: string]: string } = {
    healthy: '#28a745',
    warning: '#ffc107',
    critical: '#dc3545',
    unknown: '#6c757d'
  };
  return colors[status] || colors.unknown;
};

export const getTypeColor = (type: string): string => {
  const colors: { [key: string]: string } = {
    service: '#007bff',
    database: '#17a2b8',
    external: '#6f42c1',
    frontend: '#fd7e14'
  };
  return colors[type] || '#6c757d';
};

export const interpolateColor = (color1: string, color2: string, factor: number): string => {
  const hex1 = color1.replace('#', '');
  const hex2 = color2.replace('#', '');
  
  const r1 = parseInt(hex1.substr(0, 2), 16);
  const g1 = parseInt(hex1.substr(2, 2), 16);
  const b1 = parseInt(hex1.substr(4, 2), 16);
  
  const r2 = parseInt(hex2.substr(0, 2), 16);
  const g2 = parseInt(hex2.substr(2, 2), 16);
  const b2 = parseInt(hex2.substr(4, 2), 16);
  
  const r = Math.round(r1 + (r2 - r1) * factor);
  const g = Math.round(g1 + (g2 - g1) * factor);
  const b = Math.round(b1 + (b2 - b1) * factor);
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
};

export const getGradientColor = (value: number, min: number, max: number): string => {
  const normalizedValue = Math.max(0, Math.min(1, (value - min) / (max - min)));
  const colors = ['#28a745', '#ffc107', '#dc3545']; // Green to Yellow to Red
  
  if (normalizedValue <= 0.5) {
    return interpolateColor(colors[0], colors[1], normalizedValue * 2);
  } else {
    return interpolateColor(colors[1], colors[2], (normalizedValue - 0.5) * 2);
  }
};

// ============= src/components/ServiceMapRenderer.ts =============
import * as d3 from 'd3';
import { ServiceMapData, D3Node, D3Edge, GraphConfig, GraphSelection } from '@/types';
import { GraphService } from '@/services/GraphService';
import { getNodeTooltipContent, getEdgeTooltipContent } from '@/utils/graphUtils';

export class ServiceMapRenderer {
  private svg: d3.Selection<SVGElement, unknown, null, undefined>;
  private container: d3.Selection<SVGGElement, unknown, null, undefined>;
  private graphService: GraphService;
  private config: GraphConfig;
  private data: ServiceMapData | null = null;
  private selection: GraphSelection = { selectedNodes: [], selectedEdges: [] };
  private zoom: d3.ZoomBehavior<SVGElement, unknown>;
  private tooltip: d3.Selection<HTMLDivElement, unknown, null, undefined>;

  constructor(container: HTMLElement, config: GraphConfig) {
    this.config = config;
    this.graphService = new GraphService(config);
    
    // Create SVG
    this.svg = d3.select(container)
      .append('svg')
      .attr('width', config.layout.width)
      .attr('height', config.layout.height);

    // Create zoom behavior
    this.zoom = d3.zoom<SVGElement, unknown>()
      .scaleExtent([0.1, 4])
      .on('zoom', (event) => {
        this.container.attr('transform', event.transform);
      });

    this.svg.call(this.zoom);

    // Create main container
    this.container = this.svg.append('g').attr('class', 'graph-container');

    // Create tooltip
    this.tooltip = d3.select('body')
      .append('div')
      .attr('class', 'graph-tooltip')
      .style('opacity', 0)
      .style('position', 'absolute')
      .style('background', 'rgba(0, 0, 0, 0.8)')
      .style('color', 'white')
      .style('padding', '10px')
      .style('border-radius', '5px')
      .style('pointer-events', 'none')
      .style('font-size', '12px')
      .style('z-index', '1000');
  }

  public render(data: ServiceMapData): void {
    this.data = data;
    
    // Convert to D3 format
    const nodes: D3Node[] = data.nodes.map(node => ({ ...node }));
    const edges: D3Edge[] = data.edges.map(edge => ({ ...edge }));

    // Clear existing elements
    this.container.selectAll('*').remove();

    // Create arrow markers for directed edges
    const defs = this.svg.append('defs');
    
    defs.selectAll('marker')
      .data(['healthy', 'warning', 'critical'])
      .enter()
      .append('marker')
      .attr('id', d => `arrow-${d}`)
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 15)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5')
      .attr('fill', d => this.graphService.getEdgeColor({ status: d } as any));

    // Create link elements
    const linkGroup = this.container.append('g').attr('class', 'links');
    const links = linkGroup.selectAll('line')
      .data(edges)
      .enter()
      .append('line')
      .attr('class', 'link')
      .attr('stroke', d => this.graphService.getEdgeColor(d))
      .attr('stroke-width', d => this.graphService.getEdgeWidth(d))
      .attr('marker-end', d => `url(#arrow-${d.status})`)
      .style('cursor', 'pointer')
      .on('mouseover', (event, d) => this.showEdgeTooltip(event, d))
      .on('mouseout', () => this.hideTooltip())
      .on('click', (event, d) => this.selectEdge(d));

    // Create node elements
    const nodeGroup = this.container.append('g').attr('class', 'nodes');
    const nodeElements = nodeGroup.selectAll('g')
      .data(nodes)
      .enter()
      .append('g')
      .attr('class', 'node')
      .style('cursor', 'pointer')
      .call(d3.drag<SVGGElement, D3Node>()
        .on('start', (event, d) => this.dragStarted(event, d))
        .on('drag', (event, d) => this.dragged(event, d))
        .on('end', (event, d) => this.dragEnded(event, d)))
      .on('mouseover', (event, d) => this.showNodeTooltip(event, d))
      .on('mouseout', () => this.hideTooltip())
      .on('click', (event, d) => this.selectNode(d));

    // Add circles for nodes
    nodeElements.append('circle')
      .attr('r', this.config.visual.nodeRadius)
      .attr('fill', d => this.graphService.getNodeColor(d))
      .attr('stroke', '#fff')
      .attr('stroke-width', this.config.visual.strokeWidth);

    // Add status indicator rings
    nodeElements
      .filter(d => d.status !== 'healthy')
      .append('circle')
      .attr('r', this.config.visual.nodeRadius + 4)
      .attr('fill', 'none')
      .attr('stroke', d => this.graphService.getNodeColor(d))
      .attr('stroke-width', 2)
      .attr('stroke-dasharray', '3,3');

    // Add labels for nodes
    nodeElements.append('text')
      .attr('dy', this.config.visual.nodeRadius + 15)
      .attr('text-anchor', 'middle')
      .style('font-size', `${this.config.visual.fontSize}px`)
      .style('font-family', 'Arial, sans-serif')
      .style('fill', '#333')
      .text(d => d.name);

    // Add metric indicators
    nodeElements
      .filter(d => d.metrics.errorRate > 0.05)
      .append('circle')
      .attr('r', 3)
      .attr('cx', this.config.visual.nodeRadius - 5)
      .attr('cy', -this.config.visual.nodeRadius + 5)
      .attr('fill', '#dc3545')
      .append('title')
      .text(d => `High error rate: ${(d.metrics.errorRate * 100).toFixed(2)}%`);

    // Create simulation
    const simulation = this.graphService.createSimulation(nodes, edges);
    
    simulation.on('tick', () => {
      links
        .attr('x1', d => (d.source as D3Node).x!)
        .attr('y1', d => (d.source as D3Node).y!)
        .attr('x2', d => (d.target as D3Node).x!)
        .attr('y2', d => (d.target as D3Node).y!);

      nodeElements
        .attr('transform', d => `translate(${d.x},${d.y})`);
    });
  }

  private dragStarted(event: d3.D3DragEvent<SVGGElement, D3Node, D3Node>, d: D3Node): void {
    if (!event.active) this.graphService.restartSimulation();
    d.fx = d.x;
    d.fy = d.y;
  }

  private dragged(event: d3.D3DragEvent<SVGGElement, D3Node, D3Node>, d: D3Node): void {
    d.fx = event.x;
    d.fy = event.y;
  }

  private dragEnded(event: d3.D3DragEvent<SVGGElement, D3Node, D3Node>, d: D3Node): void {
    if (!event.active) this.graphService.stopSimulation();
    d.fx = null;
    d.fy = null;
  }

  private showNodeTooltip(event: MouseEvent, node: D3Node): void {
    this.tooltip
      .style('opacity', 1)
      .html(getNodeTooltipContent(node))
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 10) + 'px');
  }

  private showEdgeTooltip(event: MouseEvent, edge: D3Edge): void {
    this.tooltip
      .style('opacity', 1)
      .html(getEdgeTooltipContent(edge))
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 10) + 'px');
  }

  private hideTooltip(): void {
    this.tooltip.style('opacity', 0);
  }

  private selectNode(node: D3Node): void {
    const index = this.selection.selectedNodes.indexOf(node.id);
    if (index > -1) {
      this.selection.selectedNodes.splice(index, 1);
    } else {
      this.selection.selectedNodes.push(node.id);
    }
    this.updateSelection();
  }

  private selectEdge(edge: D3Edge): void {
    const index = this.selection.selectedEdges.indexOf(edge.id);
    if (index > -1) {
      this.selection.selectedEdges.splice(index, 1);
    } else {
      this.selection.selectedEdges.push(edge.id);
    }
    this.updateSelection();
  }

  private updateSelection(): void {
    // Update visual selection indicators
    this.container.selectAll('.node circle')
      .attr('stroke-width', (d: any) => 
        this.selection.selectedNodes.includes(d.id) ? 4 : this.config.visual.strokeWidth);
    
    this.container.selectAll('.link')
      .attr('stroke-width', (d: any) => 
        this.selection.selectedEdges.includes(d.id) ? 
        this.graphService.getEdgeWidth(d) + 2 : this.graphService.getEdgeWidth(d));
  }

  public centerView(): void {
    const bounds = this.container.node()?.getBBox();
    if (!bounds) return;

    const { width, height } = this.config.layout;
    const scale = Math.min(width / bounds.width, height / bounds.height) * 0.9;
    const centerX = width / 2;
    const centerY = height / 2;
    const x = centerX - scale * (bounds.x + bounds.width / 2);
    const y = centerY - scale * (bounds.y + bounds.height / 2);

    this.svg.transition()
      .duration(750)
      .call(this.zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
  }

  public fitToScreen(): void {
    this.centerView();
  }

  public resetZoom(): void {
    this.svg.transition()
      .duration(750)
      .call(this.zoom.transform, d3.zoomIdentity);
  }

  public highlightPath(nodeIds: string[]): void {
    // Dim all nodes and edges
    this.container.selectAll('.node').style('opacity', 0.3);
    this.container.selectAll('.link').style('opacity', 0.3);

    // Highlight selected path
    this.container.selectAll('.node')
      .filter((d: any) => nodeIds.includes(d.id))
      .style('opacity', 1);

    this.container.selectAll('.link')
      .filter((d: any) => nodeIds.includes(d.source.id) && nodeIds.includes(d.target.id))
      .style('opacity', 1);
  }

  public clearHighlight(): void {
    this.container.selectAll('.node').style('opacity', 1);
    this.container.selectAll('.link').style('opacity', 1);
  }

  public destroy(): void {
    this.graphService.stopSimulation();
    this.svg.remove();
    this.tooltip.remove();
  }
}

// ============= src/components/ServiceMapPanel.ts =============
import { PanelBuilders, SceneFlexItem, SceneFlexLayout, VizPanel } from '@grafana/scenes';
import React from 'react';
import { ServiceMapRenderer } from './ServiceMapRenderer';
import { DataService } from '@/services/DataService';
import { GraphConfig, ServiceMapData } from '@/types';

export interface ServiceMapPanelState {
  data?: ServiceMapData;
  loading: boolean;
  error?: string;
}

export class ServiceMapPanel extends SceneFlexItem {
  private renderer: ServiceMapRenderer | null = null;
  private dataService: DataService;
  private config: GraphConfig;

  constructor() {
    super({
      body: new VizPanel({
        title: 'Service Map',
        pluginId: 'custom-servicemap',
        options: {},
      }),
    });

    this.dataService = DataService.getInstance();
    this.config = this.getDefaultConfig();
  }

  private getDefaultConfig(): GraphConfig {
    return {
      layout: {
        width: 1200,
        height: 800,
        padding: 50
      },
      simulation: {
        forceStrength: 0.5,
        linkDistance: 100,
        chargeStrength: -300,
        centerStrength: 0.1
      },
      visual: {
        nodeRadius: 20,
        strokeWidth: 2,
        fontSize: 12,
        colors: {
          primary: '#007bff',
          success: '#28a745',
          warning: '#ffc107',
          danger: '#dc3545',
          info: '#17a2b8'
        }
      }
    };
  }

  public async activate(): Promise<void> {
    await super.activate();
    await this.loadData();
  }

  private async loadData(): Promise<void> {
    try {
      const data = await this.dataService.fetchServiceMapData();
      this.renderServiceMap(data);
    } catch (error) {
      console.error('Failed to load service map data:', error);
    }
  }

  private renderServiceMap(data: ServiceMapData): void {
    // Get the panel container
    const panelElement = document.querySelector('[data-testid="panel-content"]') as HTMLElement;
    if (!panelElement) {
      console.error('Panel container not found');
      return;
    }

    // Clean up existing renderer
    if (this.renderer) {
      this.renderer.destroy();
    }

    // Create new renderer
    this.renderer = new ServiceMapRenderer(panelElement, this.config);
    this.renderer.render(data);

    // Auto-fit to screen after initial render
    setTimeout(() => {
      this.renderer?.fitToScreen();
    }, 1000);
  }

  public onRefresh(): void {
    this.loadData();
  }

  public onResize(width: number, height: number): void {
    this.config.layout.width = width;
    this.config.layout.height = height;
    
    if (this.renderer) {
      // Re-render with new dimensions
      this.loadData();
    }
  }

  public highlightCriticalPath(): void {
    if (!this.renderer) return;
    
    // Find and highlight critical services
    this.dataService.fetchServiceMapData().then(data => {
      const criticalNodes = data.nodes
        .filter(node => node.status === 'critical' || node.metrics.errorRate > 0.1)
        .map(node => node.id);
      
      this.renderer?.highlightPath(criticalNodes);
    });
  }

  public clearHighlight(): void {
    this.renderer?.clearHighlight();
  }

  public centerView(): void {
    this.renderer?.centerView();
  }

  public resetZoom(): void {
    this.renderer?.resetZoom();
  }
}

// ============= src/components/ServiceMapScene.ts =============
import {
  EmbeddedScene,
  SceneAppPage,
  SceneAppPageState,
  SceneFlexLayout,
  SceneFlexItem,
  SceneRefreshPicker,
  SceneTimePicker,
  SceneControlsSpacer,
  ToolbarButton
} from '@grafana/scenes';
import { ServiceMapPanel } from './ServiceMapPanel';

export interface ServiceMapSceneState extends SceneAppPageState {
  title: string;
  url: string;
}

export class ServiceMapScene extends SceneAppPage<ServiceMapSceneState> {
  private serviceMapPanel: ServiceMapPanel;

  constructor() {
    const serviceMapPanel = new ServiceMapPanel();
    
    super({
      title: 'Service Map Dashboard',
      url: '/servicemap',
      $timeRange: {
        from: 'now-1h',
        to: 'now'
      },
      controls: [
        new ToolbarButton({
          title: 'Refresh',
          icon: 'sync',
          onClick: () => this.onRefresh(),
        }),
        new ToolbarButton({
          title: 'Center View',
          icon: 'search-plus',
          onClick: () => this.centerView(),
        }),
        new ToolbarButton({
          title: 'Highlight Critical Path',
          icon: 'exclamation-triangle',
          onClick: () => this.highlightCriticalPath(),
        }),
        new ToolbarButton({
          title: 'Clear Highlight',
          icon: 'times',
          onClick: () => this.clearHighlight(),
        }),
        new SceneControlsSpacer(),
        new SceneRefreshPicker({
          intervals: ['5s', '10s', '30s', '1m', '5m', '15m', '30m', '1h'],
          autoEnabled: true,
        }),
        new SceneTimePicker({}),
      ],
      body: new SceneFlexLayout({
        direction: 'column',
        children: [
          new SceneFlexItem({
            minHeight: 800,
            body: serviceMapPanel,
          }),
        ],
      }),
    });

    this.serviceMapPanel = serviceMapPanel;
  }

  private onRefresh(): void {
    this.serviceMapPanel.onRefresh();
  }

  private centerView(): void {
    this.serviceMapPanel.centerView();
  }

  private highlightCriticalPath(): void {
    this.serviceMapPanel.highlightCriticalPath();
  }

  private clearHighlight(): void {
    this.serviceMapPanel.clearHighlight();
  }

  public static getScene(): ServiceMapScene {
    return new ServiceMapScene();
  }
}

// ============= src/styles/servicemap.css =============
.graph-container {
  font-family: 'Roboto', 'Helvetica Neue', Arial, sans-serif;
}

.node {
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.node:hover {
  filter: brightness(1.1);
}

.node circle {
  transition: stroke-width 0.2s ease-in-out;
}

.link {
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.link:hover {
  filter: brightness(1.2);
}

.graph-tooltip {
  background: rgba(0, 0, 0, 0.9) !important;
  color: white !important;
  padding: 12px !important;
  border-radius: 6px !important;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
  font-size: 13px !important;
  line-height: 1.4 !important;
  max-width: 300px !important;
  word-wrap: break-word !important;
}

.tooltip-content h4 {
  margin: 0 0 8px 0 !important;
  color: #fff !important;
  font-size: 14px !important;
  font-weight: 600 !important;
}

.tooltip-content p {
  margin: 4px 0 !important;
  color: #e0e0e0 !important;
}

.tooltip-content strong {
  color: #fff !important;
}

/* Service type specific styles */
.node.service circle {
  filter: drop-shadow(0 2px 4px rgba(0, 123, 255, 0.3));
}

.node.database circle {
  filter: drop-shadow(0 2px 4px rgba(23, 162, 184, 0.3));
}

.node.external circle {
  filter: drop-shadow(0 2px 4px rgba(111, 66, 193, 0.3));
}

.node.frontend circle {
  filter: drop-shadow(0 2px 4px rgba(253, 126, 20, 0.3));
}

/* Status indicators */
.node.critical circle {
  animation: pulse-critical 2s infinite;
}

.node.warning circle {
  animation: pulse-warning 3s infinite;
}

@keyframes pulse-critical {
  0% { filter: drop-shadow(0 0 0 rgba(220, 53, 69, 0.7)); }
  50% { filter: drop-shadow(0 0 10px rgba(220, 53, 69, 0.9)); }
  100% { filter: drop-shadow(0 0 0 rgba(220, 53, 69, 0.7)); }
}

@keyframes pulse-warning {
  0% { filter: drop-shadow(0 0 0 rgba(255, 193, 7, 0.6)); }
  50% { filter: drop-shadow(0 0 8px rgba(255, 193, 7, 0.8)); }
  100% { filter: drop-shadow(0 0 0 rgba(255, 193, 7, 0.6)); }
}

/* Edge animations for high traffic */
.link.high-traffic {
  stroke-dasharray: 5,5;
  animation: dash 1s linear infinite;
}

@keyframes dash {
  to { stroke-dashoffset: -10; }
}

/* Selection styles */
.node.selected circle {
  stroke: #007bff !important;
  stroke-width: 4px !important;
  filter: drop-shadow(0 0 8px rgba(0, 123, 255, 0.6));
}

.link.selected {
  stroke: #007bff !important;
  filter: drop-shadow(0 0 4px rgba(0, 123, 255, 0.4));
}

/* Panel container styles */
.servicemap-panel {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
  background: #fafafa;
}

.servicemap-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 100;
  display: flex;
  gap: 8px;
}

.servicemap-controls button {
  padding: 6px 12px;
  background: rgba(255, 255, 255, 0.9);
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

.servicemap-controls button:hover {
  background: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Legend */
.servicemap-legend {
  position: absolute;
  bottom: 20px;
  left: 20px;
  background: rgba(255, 255, 255, 0.95);
  padding: 15px;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  font-size: 12px;
}

.legend-item {
  display: flex;
  align-items: center;
  margin-bottom: 6px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 8px;
}

/* Responsive design */
@media (max-width: 768px) {
  .servicemap-controls {
    position: relative;
    top: auto;
    right: auto;
    margin-bottom: 10px;
    justify-content: center;
  }
  
  .servicemap-legend {
    position: relative;
    bottom: auto;
    left: auto;
    margin-top: 10px;
  }
  
  .graph-tooltip {
    font-size: 11px !important;
    max-width: 250px !important;
  }
}

// ============= src/index.ts =============
import { ServiceMapScene } from '@/components/ServiceMapScene';
import { DataService } from '@/services/DataService';
import '@/styles/servicemap.css';

// Initialize the application
export class ServiceMapApp {
  private scene: ServiceMapScene;
  private dataService: DataService;

  constructor() {
    this.dataService = DataService.getInstance();
    this.scene = ServiceMapScene.getScene();
  }

  public async initialize(container: HTMLElement): Promise<void> {
    try {
      // Initialize data service
      await this.dataService.fetchServiceMapData();
      
      // Activate the scene
      await this.scene.activate();
      
      console.log('ServiceMap application initialized successfully');
    } catch (error) {
      console.error('Failed to initialize ServiceMap application:', error);
      throw error;
    }
  }

  public getScene(): ServiceMapScene {
    return this.scene;
  }
}

// Export main application instance
export const app = new ServiceMapApp();

// Export all types and components for external use
export * from '@/types';
export * from '@/components/ServiceMapScene';
export * from '@/components/ServiceMapPanel';
export * from '@/components/ServiceMapRenderer';
export * from '@/services/DataService';
export * from '@/services/GraphService';
export * from '@/utils/graphUtils';
export * from '@/utils/colorUtils';

// Default export
export default ServiceMapApp;

// ============= README.md =============
# Grafana Scenes ServiceMap Application

A comprehensive Node.js TypeScript application for building custom Grafana Scenes with interactive ServiceMap Graph visualizations. This application provides real-time service topology visualization with advanced features like drag-and-drop nodes, status indicators, metric overlays, and critical path highlighting.

## Features

### Core Functionality
- **Interactive Service Topology**: Drag-and-drop nodes with force-directed graph layout
- **Real-time Metrics**: Display service health, request rates, error rates, and latency
- **Status Indicators**: Visual health indicators with color coding and animations
- **Critical Path Detection**: Automatically highlight problematic service chains
- **Zoom & Pan**: Full viewport control with fit-to-screen functionality
- **Tooltips**: Detailed metric information on hover
- **Selection**: Multi-select nodes and edges for detailed analysis

### Advanced Features
- **Graph Simulation**: Physics-based layout using D3.js force simulation
- **Custom Styling**: CSS animations for status indicators and traffic flow
- **Responsive Design**: Mobile-friendly layout adaptation
- **TypeScript Support**: Full type safety and IntelliSense
- **Modular Architecture**: Clean separation of concerns with services and utils

## Project Structure

```
grafana-scenes-servicemap/
├── src/
│   ├── components/          # Scene and panel components
│   ├── services/           # Data and graph services
│   ├── types/              # TypeScript type definitions
│   ├── utils/              # Utility functions
│   └── styles/             # CSS styling
├── dist/                   # Built application
└── configuration files
```

## Installation

```bash
# Clone the repository
git clone <repository-url>
cd grafana-scenes-servicemap

# Install dependencies
npm install

# Build the application
npm run build

# Start development server
npm run dev
```

## Usage

### Basic Implementation

```typescript
import { ServiceMapApp } from './src/index';

const app = new ServiceMapApp();
const container = document.getElementById('servicemap-container');

app.initialize(container).then(() => {
  console.log('ServiceMap loaded successfully');
});
```

### Custom Configuration

```typescript
const customConfig = {
  layout: { width: 1600, height: 1000, padding: 60 },
  simulation: { 
    forceStrength: 0.7, 
    linkDistance: 120, 
    chargeStrength: -400 
  },
  visual: { nodeRadius: 25, fontSize: 14 }
};
```

### Data Integration

```typescript
// Custom data service
class CustomDataService extends DataService {
  async fetchServiceMapData(): Promise<ServiceMapData> {
    const response = await fetch('/api/servicemap');
    return response.json();
  }
}
```

## API Reference

### ServiceNode Interface
```typescript
interface ServiceNode {
  id: string;
  name: string;
  type: 'service' | 'database' | 'external' | 'frontend';
  status: 'healthy' | 'warning' | 'critical' | 'unknown';
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
    cpu: number;
    memory: number;
  };
}
```

### ServiceEdge Interface
```typescript
interface ServiceEdge {
  id: string;
  source: string;
  target: string;
  type: 'http' | 'grpc' | 'database' | 'message_queue';
  metrics: {
    requestRate: number;
    errorRate: number;
    latency: number;
    throughput: number;
  };
}
```

## Customization

### Node Styling
Override node colors and sizes based on metrics:

```typescript
// Custom node color logic
getNodeColor(node: ServiceNode): string {
  if (node.metrics.cpu > 80) return '#dc3545'; // Red for high CPU
  if (node.metrics.errorRate > 0.05) return '#ffc107'; // Yellow for errors
  return '#28a745'; // Green for healthy
}
```

### Edge Styling
Customize edge appearance based on traffic:

```typescript
// Custom edge width based on request rate
getEdgeWidth(edge: ServiceEdge): number {
  const minWidth = 1;
  const maxWidth = 10;
  const normalized = edge.metrics.requestRate / 1000;
  return Math.max(minWidth, Math.min(maxWidth, normalized * maxWidth));
}
```

## Development

### Scripts
- `npm run build` - Production build
- `npm run dev` - Development with watch mode
- `npm start` - Start development server
- `npm run type-check` - TypeScript validation

### Adding New Features

1. **New Metrics**: Extend `ServiceNode` and `ServiceEdge` interfaces
2. **Custom Renderers**: Inherit from `ServiceMapRenderer`
3. **Data Sources**: Implement custom `DataService` classes
4. **Styling**: Add CSS classes in `/styles/servicemap.css`

## Integration with Grafana

This application is designed to work seamlessly with Grafana Scenes:

```typescript
// Plugin integration
export const plugin = new GrafanaPlugin()
  .setRootPage(() => ServiceMapScene.getScene())
  .configureExtensionPoint({
    title: 'Service Map',
    description: 'Interactive service topology visualization'
  });
```

## Performance Considerations

- **Large Graphs**: Implements viewport culling for 500+ nodes
- **Real-time Updates**: Efficient diff-based re-rendering
- **Memory Management**: Proper cleanup of D3 simulations and event listeners
- **Responsive**: Adaptive layout for different screen sizes

## Browser Support

- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+

## Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Submit a pull request

## License

MIT License - see LICENSE file for details
